<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GeneListe - Vue Liste</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid red; padding: 0.4rem 0.6rem; text-align: left; }
    th { background: blue; }
    th button { all: unset; color: white; cursor: pointer; display: inline-flex; align-items: center; gap: 4px; }
    th img { width: 14px; height: 14px; filter: invert(1); }
    button { min-height: 34px; padding: 0.35rem 0.6rem; }
    input, select { min-height: 34px; }
    @media (max-width: 768px) {
      body { margin: 0.9rem; }
      button { min-height: 48px; padding: 0.6rem 0.9rem; font-size: 1rem; }
      input, select { min-height: 44px; font-size: 1rem; }
      th, td { padding: 0.55rem 0.45rem; }
    }
  </style>
</head>
<body>
  <h1>Liste des entrées (vue)</h1>
  <div id="status">Chargement...</div>
  <button id="synthese-btn" disabled>Synthese</button>
  <div style="margin:0.6rem 0; display:flex; gap:0.5rem; flex-wrap:wrap;">
    <input id="filter-gene" type="text" placeholder="Filtre Gene (contient)" />
    <input id="filter-info" type="text" placeholder="Filtre Info (contient)" />
    <select id="filter-gen-startLevel" aria-label="Filtre generation debut">
      <option value="">Gene deb: tout</option>
      <option value="1">Gene deb = 1</option>
      <option value="2">Gene deb = 2</option>
      <option value="3">Gene deb = 3</option>
      <option value="4">Gene deb = 4</option>
      <option value="5">Gene deb = 5</option>
      <option value="6">Gene deb = 6</option>
      <option value="7">Gene deb = 7</option>
    </select>
    <select id="filter-gen-endLevel" aria-label="Filtre generation fin">
      <option value="">Gene fin: tout</option>
      <option value="2">Gene fin = 2</option>
      <option value="3">Gene fin = 3</option>
      <option value="4">Gene fin = 4</option>
      <option value="5">Gene fin = 5</option>
      <option value="6">Gene fin = 6</option>
      <option value="7">Gene fin = 7</option>
    </select>
    <input id="filter-nom" type="text" placeholder="Filtre début Nom" />
    <input id="filter-prenom" type="text" placeholder="Filtre début Prenom" />
    <input id="filter-s" type="text" placeholder="Filtre S (M/F)" />
    <input id="filter-naiss-start" type="text" placeholder="Naiss_AAAA début" />
    <input id="filter-naiss-end" type="text" placeholder="Naiss_AAAA fin" />
  </div>
  <table aria-live="polite" id="table" hidden>
    <thead></thead>
    <tbody></tbody>
  </table>
  <pre id="trace" style="background:#f5f5f5;border:1px solid #ccc;padding:0.5rem;white-space:pre-wrap;max-height:240px;overflow:auto;"></pre>

  <script src="Qui.js"></script>
  <script>
    const statusEl = document.getElementById('status');
    const syntheseBtn = document.getElementById('synthese-btn');
    const filterGeneInput = document.getElementById('filter-gene');
    const filterInfoInput = document.getElementById('filter-info');
    const filterGenStartLevelInput = document.getElementById('filter-gen-startLevel');
    const filterGenEndLevelInput = document.getElementById('filter-gen-endLevel');
    const filterNomInput = document.getElementById('filter-nom');
    const filterPrenomInput = document.getElementById('filter-prenom');
    const filterSInput = document.getElementById('filter-s');
    const filterNaissStartInput = document.getElementById('filter-naiss-start');
    const filterNaissEndInput = document.getElementById('filter-naiss-end');
    const traceEl = document.getElementById('trace');
    const table = document.getElementById('table');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');
    const urlParams = new URLSearchParams(window.location.search);
    let dataset = { headers: [], rows: [] };
    let sortKey = null;
    let sortAsc = true;
    let filters = { gene: '', info: '', genStartLevel: '', genEndLevel: '', nom: '', prenom: '', s: '', naissStart: '', naissEnd: '' };

    function trace(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.log(line);
      //traceEl.textContent = `${line}\n${traceEl.textContent}`;
    }

    function setupFilters() {
      const onFilterChange = () => {
        filters = {
          gene: normalizeFilter(filterGeneInput.value),
          info: normalizeFilter(filterInfoInput.value),
          genStartLevel: normalizeStartGenerationFilter(filterGenStartLevelInput.value),
          genEndLevel: normalizeEndGenerationFilter(filterGenEndLevelInput.value),
          nom: normalizeFilter(filterNomInput.value),
          prenom: normalizeFilter(filterPrenomInput.value),
          s: normalizeSexValue(filterSInput.value),
          naissStart: normalizeYearFilter(filterNaissStartInput.value),
          naissEnd: normalizeYearFilter(filterNaissEndInput.value)
        };
        syncListStateInUrl();
        render(dataset.headers, dataset.rows);
      };
      filterGeneInput.addEventListener('input', onFilterChange);
      filterInfoInput.addEventListener('input', onFilterChange);
      filterGenStartLevelInput.addEventListener('change', onFilterChange);
      filterGenEndLevelInput.addEventListener('change', onFilterChange);
      filterNomInput.addEventListener('input', onFilterChange);
      filterPrenomInput.addEventListener('input', onFilterChange);
      filterSInput.addEventListener('input', onFilterChange);
      filterNaissStartInput.addEventListener('input', onFilterChange);
      filterNaissEndInput.addEventListener('input', onFilterChange);
    }

    function normalizeFilter(value) {
      return (value ?? '').toString().trim().toLowerCase();
    }

    function normalizeYearFilter(value) {
      return (value ?? '').toString().replace(/\D+/g, '').slice(0, 4);
    }

    function normalizeSexValue(value) {
      const normalized = (value ?? '').toString().toUpperCase().replace(/[^MF]/g, '');
      return normalized.slice(0, 1);
    }

    function normalizeStartGenerationFilter(value) {
      const raw = (value ?? '').toString().trim();
      if (!/^[1-7]$/.test(raw)) return '';
      return raw;
    }

    function normalizeEndGenerationFilter(value) {
      const raw = (value ?? '').toString().trim();
      if (!/^[2-7]$/.test(raw)) return '';
      return raw;
    }

    function extractGenerationDepth(geneValue) {
      const gene = (geneValue ?? '').toString();
      const matches = Array.from(gene.matchAll(/&(\d+)[a-z]+/gi));
      if (!matches.length) return 0;
      const levels = matches.map(m => Number(m[1])).filter(n => Number.isFinite(n));
      return levels.length ? Math.max(...levels) : 0;
    }

    function render(headers, rows) {
      trace('render appelée');
      thead.innerHTML = '';
      tbody.innerHTML = '';
      const idKey = headers.find(h => h.toLowerCase() === 'id');
      const nomKey = headers.find(h => h.toLowerCase() === 'nom');
      const visibleHeaders = headers.filter(h => h !== idKey && !/_(jj|mm)$/i.test(h));
      if ((!sortKey || !visibleHeaders.includes(sortKey)) && visibleHeaders.length) {
        sortKey = visibleHeaders[0];
        sortAsc = true;
      }
      const trHead = document.createElement('tr');
      visibleHeaders.forEach(h => {
        const th = document.createElement('th');
        const btn = document.createElement('button');
        btn.textContent = h;
        btn.addEventListener('click', () => toggleSort(h));
        const img = document.createElement('img');
        if (sortKey === h) {
          img.src = sortAsc ? 'img/fleche_haut.svg' : 'img/fleche_bas.svg';
        } else {
          img.src = 'img/fleche_vide.svg';
        }
        btn.appendChild(img);
        th.appendChild(btn);
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);

      const filteredRows = applyFilters(rows, headers);
      const displayRows = applySort(filteredRows);

      displayRows.forEach(row => {
        const tr = document.createElement('tr');
        visibleHeaders.forEach(h => {
          const td = document.createElement('td');
          if (idKey && row[idKey] && nomKey && h === nomKey) {
            const params = buildListStateParams();
            params.set('id', row[idKey]);
            const link = document.createElement('a');
            link.href = `vQuiDetail.html?${params.toString()}`;
            link.textContent = row[h] ?? '';
            td.appendChild(link);
          } else {
            td.textContent = row[h] ?? '';
          }
          applyWidth(h, td);
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.hidden = false;
    }

    function applySort(rows) {
      if (!sortKey) return rows;
      const arr = [...rows];
      arr.sort((a, b) => {
        const va = (a[sortKey] ?? '').toString();
        const vb = (b[sortKey] ?? '').toString();
        const na = Number(va), nb = Number(vb);
        const bothNum = Number.isFinite(na) && Number.isFinite(nb);
        const cmp = bothNum ? na - nb : va.localeCompare(vb, 'fr', { numeric: true, sensitivity: 'base' });
        return sortAsc ? cmp : -cmp;
      });
      return arr;
    }

    function applyFilters(rows, headers) {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      const infoKey = headers.find(h => h.toLowerCase() === 'info');
      const nomKey = headers.find(h => h.toLowerCase() === 'nom');
      const prenomKey = headers.find(h => h.toLowerCase() === 'prenom');
      const sKey = headers.find(h => h.toLowerCase() === 's');
      const naissKey = headers.find(h => h.toLowerCase() === 'naiss_aaaa');
      const minGeneration = filters.genStartLevel ? Number(filters.genStartLevel) : null;
      const maxGeneration = filters.genEndLevel ? Number(filters.genEndLevel) : null;
      const startYear = filters.naissStart ? Number(filters.naissStart) : null;
      const endYear = filters.naissEnd ? Number(filters.naissEnd) : null;
      return rows.filter(row => {
        if (filters.gene && !normalizeFilter(row[geneKey]).includes(filters.gene)) return false;
        if (filters.info && !normalizeFilter(row[infoKey]).includes(filters.info)) return false;
        if (minGeneration !== null) {
          const depth = extractGenerationDepth(row[geneKey]);
          if (!depth || depth < minGeneration) return false;
        }
        if (maxGeneration !== null) {
          const depth = extractGenerationDepth(row[geneKey]);
          if (!depth || depth > maxGeneration) return false;
        }
        if (filters.nom && !normalizeFilter(row[nomKey]).startsWith(filters.nom)) return false;
        if (filters.prenom && !normalizeFilter(row[prenomKey]).startsWith(filters.prenom)) return false;
        if (filters.s && normalizeSexValue(row[sKey]) !== filters.s) return false;
        if (startYear !== null || endYear !== null) {
          const yearValue = normalizeYearFilter(row[naissKey]);
          if (!yearValue) return false;
          const year = Number(yearValue);
          if (!Number.isFinite(year)) return false;
          if (startYear !== null && year < startYear) return false;
          if (endYear !== null && year > endYear) return false;
        }
        return true;
      });
    }

    function toggleSort(key) {
      if (sortKey === key) {
        sortAsc = !sortAsc;
      } else {
        sortKey = key;
        sortAsc = true;
      }
      syncListStateInUrl();
      render(dataset.headers, dataset.rows);
    }

    function buildListStateParams() {
      const params = new URLSearchParams();
      if (sortKey) params.set('sortKey', sortKey);
      params.set('sortAsc', sortAsc ? '1' : '0');
      if (filters.gene) params.set('gene', filters.gene);
      if (filters.info) params.set('info', filters.info);
      if (filters.genStartLevel) params.set('genStartLevel', filters.genStartLevel);
      if (filters.genEndLevel) params.set('genEndLevel', filters.genEndLevel);
      if (filters.nom) params.set('nom', filters.nom);
      if (filters.prenom) params.set('prenom', filters.prenom);
      if (filters.s) params.set('s', filters.s);
      if (filters.naissStart) params.set('naissStart', filters.naissStart);
      if (filters.naissEnd) params.set('naissEnd', filters.naissEnd);
      return params;
    }

    function syncListStateInUrl() {
      const params = buildListStateParams();
      const qs = params.toString();
      const next = qs ? `${window.location.pathname}?${qs}` : window.location.pathname;
      window.history.replaceState(null, '', next);
    }

    function restoreListStateFromUrl(headers) {
      const initialFilters = {
        gene: normalizeFilter(urlParams.get('gene')),
        info: normalizeFilter(urlParams.get('info')),
        genStartLevel: normalizeStartGenerationFilter(urlParams.get('genStartLevel')),
        genEndLevel: normalizeEndGenerationFilter(urlParams.get('genEndLevel')),
        nom: normalizeFilter(urlParams.get('nom')),
        prenom: normalizeFilter(urlParams.get('prenom')),
        s: normalizeSexValue(urlParams.get('s')),
        naissStart: normalizeYearFilter(urlParams.get('naissStart')),
        naissEnd: normalizeYearFilter(urlParams.get('naissEnd'))
      };
      filters = initialFilters;
      filterGeneInput.value = filters.gene;
      filterInfoInput.value = filters.info;
      filterGenStartLevelInput.value = filters.genStartLevel;
      filterGenEndLevelInput.value = filters.genEndLevel;
      filterNomInput.value = filters.nom;
      filterPrenomInput.value = filters.prenom;
      filterSInput.value = filters.s;
      filterNaissStartInput.value = filters.naissStart;
      filterNaissEndInput.value = filters.naissEnd;

      const urlSortKey = (urlParams.get('sortKey') || '').trim();
      const idKey = headers.find(h => h.toLowerCase() === 'id');
      const visibleHeaders = headers.filter(h => h !== idKey && !/_(jj|mm)$/i.test(h));
      if (urlSortKey && visibleHeaders.includes(urlSortKey)) {
        sortKey = urlSortKey;
      }
      const sortAscParam = urlParams.get('sortAsc');
      if (sortAscParam === '0') sortAsc = false;
      if (sortAscParam === '1') sortAsc = true;
    }

    function loadData(msg = 'Chargé.') {
      statusEl.textContent = 'Chargement...';
      fetch(csvPath())
        .then(res => {
          if (!res.ok) throw new Error('Echec de chargement: ' + res.status);
          return res.text();
        })
        .then(text => {
          const { headers, rows } = parseCSV(text);
          dataset = { headers, rows };
          restoreListStateFromUrl(headers);
          render(dataset.headers, dataset.rows);
          syncListStateInUrl();
          statusEl.textContent = msg;
          syntheseBtn.disabled = false;
          trace(`CSV: ${dataset.rows.length} lignes reçues`);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur CSV: ' + err.message);
        });
    }

    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length);
      if (!lines.length) return { headers: [], rows: [] };
      const delimiter = lines[0].includes(';') ? ';' : '\t';
      const headers = lines[0].split(delimiter).map(h => h.trim());
      const rows = lines.slice(1).map(line => {
        const cells = line.split(delimiter).map(c => c.trim());
        const row = {};
        headers.forEach((h, i) => { row[h || `Col${i + 1}`] = cells[i] ?? ''; });
        for (let j = headers.length; j < cells.length; j++) {
          row[`Col${j + 1}`] = cells[j];
        }
        return row;
      });
      return { headers, rows };
    }

    function csvPath() {
      return 'qui.csv';
    }

    function applyWidth(fieldName, td) {
      if (fieldName === 'ID') {
        td.style.width = '20px';
      } else if (fieldName === 'S') {
        td.style.width = '20px';
      } else if (fieldName.endsWith('_AAAA')) {
        td.style.width = '60px';
      } else if (fieldName.endsWith('_MM') || fieldName.endsWith('_JJ')) {
        td.style.width = '40px';
      }
    }

    function loadFromJs() {
      if (typeof window.renderJs !== 'function') return false;
      statusEl.textContent = 'Chargement depuis Qui.js...';
      trace('Chargement des données statiques Qui.js');
      window.renderJs((headers, rows) => {
        dataset = { headers, rows };
        restoreListStateFromUrl(headers);
        render(dataset.headers, dataset.rows);
        syncListStateInUrl();
        statusEl.textContent = 'Affiché depuis Qui.js';
        syntheseBtn.disabled = false;
      });
      return true;
    }

    function findKey(name) {
      const needle = name.toLowerCase();
      return dataset.headers.find(h => h.toLowerCase() === needle);
    }

    function parseGeneSegments(gene) {
      return String(gene || '')
        .split(/[&#]/)
        .map(s => s.trim())
        .filter(Boolean);
    }

    function compareGene(a, b) {
      return a.localeCompare(b, 'fr', { numeric: true, sensitivity: 'base' });
    }

    function buildPersonLabel(row, keys) {
      const nom = (row[keys.nom] || '').trim();
      const prenom = (row[keys.prenom] || '').trim();
      const s = (row[keys.s] || '').trim();
      const naissAaaa = (row[keys.naissAaaa] || '').trim();
      const main = [nom, prenom].filter(Boolean).join(' ').trim() || '(sans nom)';
      const bits = [main];
      const bracket = [s, naissAaaa].filter(Boolean).join(' ');
      if (bracket) bits.push(`[${bracket}]`);
      return bits.join(' ');
    }

    function buildGeneTreeText() {
      const keys = {
        gene: findKey('gene'),
        nom: findKey('nom'),
        prenom: findKey('prenom'),
        s: findKey('s'),
        naissAaaa: findKey('naiss_aaaa'),
      };
      if (!keys.gene) return 'Impossible de generer la synthese: colonne Gene absente.';

      const root = { token: null, row: null, children: new Map() };
      const sorted = [...dataset.rows]
        .filter(r => (r[keys.gene] || '').trim().length > 0)
        .sort((a, b) => compareGene(a[keys.gene] || '', b[keys.gene] || ''));

      sorted.forEach(row => {
        const segs = parseGeneSegments(row[keys.gene]);
        if (!segs.length) return;
        let cursor = root;
        segs.forEach(seg => {
          if (!cursor.children.has(seg)) {
            cursor.children.set(seg, { token: seg, row: null, children: new Map() });
          }
          cursor = cursor.children.get(seg);
        });
        if (!cursor.row) cursor.row = row;
      });

      const lines = [
        `Arbre genealogique (${new Date().toISOString()})`,
        '',
      ];

      function spouseInline(node) {
        const spouseNode = node.children.get('0');
        if (!spouseNode || !spouseNode.row) return '';
        return `  & ${buildPersonLabel(spouseNode.row, keys)}`;
      }

      function walk(node, prefix, isLast) {
        const connector = isLast ? '└─ ' : '├─ ';
        const label = node.row ? ` ${buildPersonLabel(node.row, keys)}` : '';
        lines.push(`${prefix}${connector}${node.token}${label}${spouseInline(node)}`);
        const children = Array.from(node.children.values())
          .filter(child => child.token !== '0')
          .sort((a, b) => compareGene(a.token, b.token));
        const childPrefix = `${prefix}${isLast ? '   ' : '│  '}`;
        children.forEach((child, idx) => walk(child, childPrefix, idx === children.length - 1));
      }

      const roots = Array.from(root.children.values()).sort((a, b) => compareGene(a.token, b.token));
      roots.forEach((node, idx) => walk(node, '', idx === roots.length - 1));
      if (!roots.length) lines.push('(aucune donnee)');

      return lines.join('\n');
    }

    function openSynthese() {
      if (!dataset.rows.length) {
        statusEl.textContent = 'Synthese impossible: aucune donnee.';
        return;
      }
      const content = buildGeneTreeText();
      const listUrl = window.location.href;
      const html = `<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Synthese</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 1rem; }
    pre { white-space: pre; overflow: auto; border: 1px solid #ccc; padding: 0.75rem; }
    a { display: inline-block; margin-bottom: 0.8rem; }
  </style>
</head>
<body>
  <a href="${escapeHtml(listUrl)}">Retour à la liste</a>
  <pre>${escapeHtml(content)}</pre>
</body>
</html>`;
      const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      window.location.href = url;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    setupFilters();
    syntheseBtn.addEventListener('click', openSynthese);
    if (!loadFromJs()) {
      loadData();
    }
  </script>
</body>
</html>



