<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GeneListe - Détail</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    table { border-collapse: collapse; margin-top: 5px; }
    th, td { border: 1px solid #ccc; padding: 0.4rem 0.6rem; text-align: left; }
    th { background: #f3f3f3; }
    .danger { background: #ffefef; border: 1px solid #ff6b6b; color: #b00000; }
  </style>
</head>
<body>
  <h1>Détail de l'entrée</h1>
  <div id="status">Chargement...</div>
  <button id="save-btn" disabled>Enregistrer</button>
  <button id="delete-btn" class="danger" disabled>Supprimer</button>
  <button id="add-child-btn" disabled>Ajouter un enfant</button>
  <button id="add-spouse-btn" disabled>Ajouter le conjoint</button>
  <button id="add-sibling-btn" disabled>Créer frère/soeur</button>
  <button id="go-parent-btn" disabled>Aller à parent</button>
  <button id="go-spouse-btn" disabled>Aller à conjoint</button>
  <button id="go-first-child-btn" disabled>Aller à 1er enfant</button>
  <button id="go-next-sibling-btn" disabled>Aller à frère/soeur suivant</button>
  <button id="go-prev-sibling-btn" disabled>Aller à frère/soeur precedant</button>
  <table id="detail-table" hidden>
    <tbody></tbody>
  </table>
  <button id="trace-toggle-btn" type="button">Afficher la trace</button>
  <pre id="trace" hidden style="background:#f5f5f5;border:1px solid #ccc;padding:0.5rem;white-space:pre-wrap;max-height:200px;overflow:auto;"></pre>

  <script>
    const params = new URLSearchParams(window.location.search);
    const requestedId = params.get('id');
    const statusEl = document.getElementById('status');
    const saveBtn = document.getElementById('save-btn');
    const deleteBtn = document.getElementById('delete-btn');
    const addChildBtn = document.getElementById('add-child-btn');
    const addSpouseBtn = document.getElementById('add-spouse-btn');
    const addSiblingBtn = document.getElementById('add-sibling-btn');
    const goParentBtn = document.getElementById('go-parent-btn');
    const goSpouseBtn = document.getElementById('go-spouse-btn');
    const goFirstChildBtn = document.getElementById('go-first-child-btn');
    const goNextSiblingBtn = document.getElementById('go-next-sibling-btn');
    const goPrevSiblingBtn = document.getElementById('go-prev-sibling-btn');
    const traceToggleBtn = document.getElementById('trace-toggle-btn');
    const traceEl = document.getElementById('trace');
    const table = document.getElementById('detail-table');
    const tbody = table.querySelector('tbody');
    let headers = [];
    let currentRow = {};
    let idKey = null;

    function trace(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.log(line);
      traceEl.textContent = `${line}\n${traceEl.textContent}`;
    }

    function setupTraceToggle() {
      traceToggleBtn.textContent = traceEl.hidden ? 'Afficher la trace' : 'Masquer la trace';
      traceToggleBtn.addEventListener('click', () => {
        traceEl.hidden = !traceEl.hidden;
        traceToggleBtn.textContent = traceEl.hidden ? 'Afficher la trace' : 'Masquer la trace';
      });
    }

    setupTraceToggle();
    trace('QuiDetail: script chargé');
    trace(`URL=${window.location.href}`);

    function render(headers, row) {
      tbody.innerHTML = '';
      saveBtn.disabled = false;
      deleteBtn.disabled = false;
      addChildBtn.disabled = false;
      addSpouseBtn.disabled = false;
      addSiblingBtn.disabled = false;
      goParentBtn.disabled = false;
      goSpouseBtn.disabled = false;
      goFirstChildBtn.disabled = false;
      goNextSiblingBtn.disabled = false;
      goPrevSiblingBtn.disabled = false;
      const visibleHeaders = headers.filter(h => h !== idKey);
      visibleHeaders.forEach((h, idx) => {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        const td = document.createElement('td');
        th.textContent = h;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = row[h] ?? '';
        applyDigitConstraints(h, input);
        input.addEventListener('change', () => {
          const normalizedValue = normalizeFieldValue(h, input.value);
          if (input.value !== normalizedValue) input.value = normalizedValue;
          updateField(row[idKey], h, normalizedValue, td);
        });
        td.appendChild(input);
        tr.appendChild(th);
        tr.appendChild(td);
        tbody.appendChild(tr);
      });
      table.hidden = false;
    }

    function updateField(id, field, value, cell) {
      if (!id) {
        trace('ID manquant, mise à jour annulée');
        return;
      }
      cell.classList.add('saving');
      fetch(`/api/row/${encodeURIComponent(id)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, value })
      })
        .then(res => res.json())
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Mise à jour échouée');
          currentRow[field] = value;
          trace(`Champ ${field} de l'id ${id} mis à jour en mémoire`);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`Erreur mise à jour: ${err.message}`);
        })
        .finally(() => {
          cell.classList.remove('saving');
        });
    }

    function deleteRow() {
      if (!idKey || !currentRow[idKey]) return;
      const c2 = headers[1] ? currentRow[headers[1]] : '';
      const c3 = headers[2] ? currentRow[headers[2]] : '';
      const msg = `Confirmer la suppression de ${c2} ${c3}`.trim();
      if (!confirm(msg)) return;
      deleteBtn.disabled = true;
      statusEl.textContent = 'Suppression...';
      fetch(`/api/row/${encodeURIComponent(currentRow[idKey])}`, { method: 'DELETE' })
        .then(res => {
          if (!res.ok) throw new Error('Echec suppression: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Suppression échouée');
          statusEl.textContent = 'Supprimé. Pensez à enregistrer.';
          trace(`Suppression id=${currentRow[idKey]} réussie`);
          // Optionnel : vider l'affichage
          table.hidden = true;
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          setTimeout(() => window.close(), 200);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur suppression: ' + err.message);
          deleteBtn.disabled = false;
        });
    }

    function normalizeGeneBase(geneValue) {
      let gene = (geneValue ?? '').toString().trim();
      if (!gene) return '';
      if (gene.endsWith('&0')) {
        gene = gene.slice(0, -2);
      }
      if (!gene.endsWith('&')) {
        gene += '&';
      }
      return gene;
    }

    function extractNextLevel(baseGene) {
      const levels = Array.from(baseGene.matchAll(/&(\d+)[a-z]+/gi))
        .map(m => Number(m[1]))
        .filter(n => Number.isFinite(n));
      if (!levels.length) return 1;
      const lastLevel = levels[levels.length - 1];
      if (!Number.isFinite(lastLevel)) return 1;
      return lastLevel + 1;
    }

    function findNextChildRank(rows, geneKey, baseGene, level) {
      const prefix = `${baseGene}${level}`;
      const used = new Set();
      rows.forEach(row => {
        const g = (row[geneKey] ?? '').toString().trim();
        if (!g.startsWith(prefix)) return;
        const rest = g.slice(prefix.length);
        const m = /^([a-z]+)&/i.exec(rest);
        if (m) used.add(m[1].toLowerCase());
      });
      for (let code = 97; code <= 122; code += 1) {
        const letter = String.fromCharCode(code);
        if (!used.has(letter)) return letter;
      }
      return null;
    }

    function extractSiblingContext(baseGene) {
      const match = /^(.*&)(\d+)[a-z]+&$/i.exec(baseGene);
      if (!match) return null;
      return {
        parentPrefix: match[1],
        level: Number(match[2])
      };
    }

    function findNextSiblingRank(rows, geneKey, parentPrefix, level) {
      const prefix = `${parentPrefix}${level}`;
      const used = new Set();
      rows.forEach(row => {
        const g = (row[geneKey] ?? '').toString().trim();
        if (!g.startsWith(prefix)) return;
        const rest = g.slice(prefix.length);
        const m = /^([a-z]+)&/i.exec(rest);
        if (m) used.add(m[1].toLowerCase());
      });
      for (let code = 97; code <= 122; code += 1) {
        const letter = String.fromCharCode(code);
        if (!used.has(letter)) return letter;
      }
      return null;
    }

    function geneCanonical(geneValue) {
      const raw = (geneValue ?? '').toString().trim();
      if (!raw) return '';
      if (raw.endsWith('&0')) return raw;
      return normalizeGeneBase(raw);
    }

    function findRowByGene(rows, geneKey, targetGene) {
      const target = geneCanonical(targetGene);
      if (!target) return null;
      return rows.find(r => geneCanonical(r[geneKey]) === target) || null;
    }

    function navigateToGene(targetGene, actionLabel) {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!idKey || !geneKey) {
        statusEl.textContent = 'Erreur: colonnes ID/Gene absentes.';
        return;
      }
      const target = geneCanonical(targetGene);
      if (!target) {
        statusEl.textContent = `${actionLabel}: cible introuvable.`;
        return;
      }
      statusEl.textContent = `${actionLabel}...`;
      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const row = findRowByGene(rows, geneKey, target);
          if (!row || !row[idKey]) {
            statusEl.textContent = `${actionLabel}: introuvable (${target}).`;
            trace(`${actionLabel}: cible absente (${target})`);
            return;
          }
          trace(`${actionLabel}: id=${row[idKey]}, Gene=${target}`);
          window.location.href = `QuiDetail.html?id=${encodeURIComponent(row[idKey])}`;
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`${actionLabel}: ${err.message}`);
        });
    }

    function computeParentGene(rawGene) {
      const baseGene = normalizeGeneBase(rawGene);
      const segments = baseGene.match(/&\d+[a-z]+/gi) || [];
      if (segments.length <= 1) return '';
      return `${segments.slice(0, -1).join('')}&`;
    }

    function parseLastSegment(baseGene) {
      const m = /&(\d+)([a-z]+)&$/i.exec(baseGene);
      if (!m) return null;
      return { level: Number(m[1]), rank: m[2].toLowerCase() };
    }

    function findSiblingBases(rows, geneKey, parentPrefix, level) {
      const prefix = `${parentPrefix}${level}`;
      const bases = new Set();
      rows.forEach(row => {
        const gRaw = (row[geneKey] ?? '').toString().trim();
        if (!gRaw || gRaw.endsWith('&0')) return;
        const base = normalizeGeneBase(gRaw);
        if (!base.startsWith(prefix)) return;
        const rest = base.slice(prefix.length);
        // Garder uniquement les personnes exactement au niveau de fratrie (pas les descendants).
        if (!/^[a-z]+&$/i.test(rest)) return;
        bases.add(base);
      });
      return Array.from(bases).sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));
    }

    function goParent() {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!geneKey) return;
      const parentGene = computeParentGene(currentRow[geneKey]);
      navigateToGene(parentGene, 'Aller à parent');
    }

    function goSpouse() {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!geneKey) return;
      const rawGene = (currentRow[geneKey] ?? '').toString().trim();
      if (!rawGene) return;
      const baseGene = normalizeGeneBase(rawGene);
      const spouseGene = rawGene.endsWith('&0') ? baseGene : `${baseGene}0`;
      navigateToGene(spouseGene, 'Aller à conjoint');
    }

    function goFirstChild() {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!geneKey) return;
      const rawGene = (currentRow[geneKey] ?? '').toString().trim();
      if (!rawGene) return;
      const baseGene = normalizeGeneBase(rawGene);
      const level = extractNextLevel(baseGene);
      const prefix = `${baseGene}${level}`;
      statusEl.textContent = 'Aller à 1er enfant...';
      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const ranks = [];
          rows.forEach(row => {
            const gRaw = (row[geneKey] ?? '').toString().trim();
            if (!gRaw || gRaw.endsWith('&0')) return;
            const base = normalizeGeneBase(gRaw);
            if (!base.startsWith(prefix)) return;
            const rest = base.slice(prefix.length);
            const m = /^([a-z]+)&/i.exec(rest);
            if (m) ranks.push(m[1].toLowerCase());
          });
          if (!ranks.length) {
            statusEl.textContent = 'Aller à 1er enfant: aucun enfant trouvé.';
            trace('Aller à 1er enfant: aucun enfant');
            return;
          }
          ranks.sort((a, b) => a.localeCompare(b, 'fr', { sensitivity: 'base' }));
          const firstChildGene = `${prefix}${ranks[0]}&`;
          navigateToGene(firstChildGene, 'Aller à 1er enfant');
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Aller à 1er enfant: ' + err.message);
        });
    }

    function goSibling(direction) {
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!geneKey) return;
      const rawGene = (currentRow[geneKey] ?? '').toString().trim();
      if (!rawGene) return;
      const baseGene = normalizeGeneBase(rawGene);
      const currentSeg = parseLastSegment(baseGene);
      const siblingCtx = extractSiblingContext(baseGene);
      const actionLabel = direction > 0 ? 'Aller à frère/soeur suivant' : 'Aller à frère/soeur precedant';
      if (!currentSeg || !siblingCtx) {
        statusEl.textContent = `${actionLabel}: impossible depuis cette fiche.`;
        trace(`${actionLabel}: contexte Gene invalide`);
        return;
      }
      statusEl.textContent = `${actionLabel}...`;
      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const siblings = findSiblingBases(rows, geneKey, siblingCtx.parentPrefix, siblingCtx.level);
          if (!siblings.length) {
            statusEl.textContent = `${actionLabel}: aucune fratrie trouvée.`;
            return;
          }
          const currentBase = normalizeGeneBase(rawGene);
          const idx = siblings.indexOf(currentBase);
          if (idx === -1) {
            statusEl.textContent = `${actionLabel}: position courante introuvable.`;
            return;
          }
          const targetIdx = idx + (direction > 0 ? 1 : -1);
          if (targetIdx < 0 || targetIdx >= siblings.length) {
            statusEl.textContent = `${actionLabel}: aucun ${direction > 0 ? 'suivant' : 'precedant'}.`;
            return;
          }
          navigateToGene(siblings[targetIdx], actionLabel);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`${actionLabel}: ${err.message}`);
        });
    }

    function addChild() {
      if (!idKey || !currentRow[idKey]) return;
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      const nomKey = headers.find(h => h.toLowerCase() === 'nom');
      if (!geneKey) {
        statusEl.textContent = 'Erreur: colonne Gene absente.';
        trace('Ajout enfant annulé: colonne Gene absente');
        return;
      }
      const parentGene = normalizeGeneBase(currentRow[geneKey]);
      if (!parentGene) {
        statusEl.textContent = 'Erreur: Gene parent vide.';
        trace('Ajout enfant annulé: Gene parent vide');
        return;
      }

      addChildBtn.disabled = true;
      statusEl.textContent = 'Ajout enfant...';

      let childId = null;
      let childGene = null;
      const parentNom = nomKey ? (currentRow[nomKey] ?? '').toString() : '';

      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const level = extractNextLevel(parentGene);
          const rank = findNextChildRank(rows, geneKey, parentGene, level);
          if (!rank) throw new Error('Plus de rang enfant disponible (a-z)');
          childGene = `${parentGene}${level}${rank}&`;
          return fetch('/api/row', { method: 'POST' });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec ajout ligne: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Ajout ligne échoué');
          childId = data.row && data.row[idKey];
          if (!childId) throw new Error('Nouvel ID introuvable');
          return fetch(`/api/row/${encodeURIComponent(childId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: geneKey, value: childGene })
          });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec update Nom enfant: ' + res.status);
          if (!nomKey) return { ok: true, json: () => Promise.resolve({ ok: true }) };
          return fetch(`/api/row/${encodeURIComponent(childId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: nomKey, value: parentNom })
          });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec update Nom enfant: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Update enfant échoué');
          statusEl.textContent = `Enfant ajouté (id=${childId}, Gene=${childGene}).`;
          trace(`Enfant ajouté: id=${childId}, Gene=${childGene}`);
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          window.location.href = `QuiDetail.html?id=${encodeURIComponent(childId)}`;
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur ajout enfant: ' + err.message);
        })
        .finally(() => {
          addChildBtn.disabled = false;
        });
    }

    function addSpouse() {
      if (!idKey || !currentRow[idKey]) return;
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      if (!geneKey) {
        statusEl.textContent = 'Erreur: colonne Gene absente.';
        trace('Ajout conjoint annulé: colonne Gene absente');
        return;
      }
      const baseGene = normalizeGeneBase(currentRow[geneKey]);
      if (!baseGene) {
        statusEl.textContent = 'Erreur: Gene vide.';
        trace('Ajout conjoint annulé: Gene vide');
        return;
      }
      const spouseGene = `${baseGene}0`;

      addSpouseBtn.disabled = true;
      statusEl.textContent = 'Ajout conjoint...';

      let spouseId = null;

      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const existing = rows.find(r => ((r[geneKey] ?? '').toString().trim() === spouseGene));
          if (existing && existing[idKey]) {
            spouseId = existing[idKey];
            return null;
          }
          return fetch('/api/row', { method: 'POST' })
            .then(res => {
              if (!res.ok) throw new Error('Echec ajout ligne: ' + res.status);
              return res.json();
            })
            .then(data => {
              if (!data.ok) throw new Error(data.error || 'Ajout ligne échoué');
              spouseId = data.row && data.row[idKey];
              if (!spouseId) throw new Error('Nouvel ID conjoint introuvable');
              return fetch(`/api/row/${encodeURIComponent(spouseId)}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ field: geneKey, value: spouseGene })
              });
            })
            .then(res => {
              if (!res.ok) throw new Error('Echec update Gene conjoint: ' + res.status);
              return res.json();
            })
            .then(data => {
              if (!data.ok) throw new Error(data.error || 'Update conjoint échoué');
            });
        })
        .then(() => {
          if (!spouseId) throw new Error('ID conjoint introuvable');
          statusEl.textContent = `Conjoint prêt (Gene=${spouseGene}).`;
          trace(`Conjoint prêt: id=${spouseId}, Gene=${spouseGene}`);
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          window.location.href = `QuiDetail.html?id=${encodeURIComponent(spouseId)}`;
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur ajout conjoint: ' + err.message);
        })
        .finally(() => {
          addSpouseBtn.disabled = false;
        });
    }

    function addSibling() {
      if (!idKey || !currentRow[idKey]) return;
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      const nomKey = headers.find(h => h.toLowerCase() === 'nom');
      if (!geneKey) {
        statusEl.textContent = 'Erreur: colonne Gene absente.';
        trace('Ajout frere/soeur annulé: colonne Gene absente');
        return;
      }
      const rawGene = (currentRow[geneKey] ?? '').toString().trim();
      if (!rawGene) {
        statusEl.textContent = 'Erreur: Gene vide.';
        trace('Ajout frere/soeur annulé: Gene vide');
        return;
      }
      if (rawGene.endsWith('&0')) {
        statusEl.textContent = 'Action impossible sur une fiche conjoint.';
        trace('Ajout frere/soeur annulé: ligne conjoint');
        return;
      }

      const baseGene = normalizeGeneBase(rawGene);
      const siblingContext = extractSiblingContext(baseGene);
      if (!siblingContext || !Number.isFinite(siblingContext.level)) {
        statusEl.textContent = 'Erreur: Gene invalide pour créer un frère/soeur.';
        trace(`Ajout frere/soeur annulé: Gene invalide (${baseGene})`);
        return;
      }

      addSiblingBtn.disabled = true;
      statusEl.textContent = 'Ajout frère/soeur...';

      let siblingId = null;
      let siblingGene = null;
      const currentNom = nomKey ? (currentRow[nomKey] ?? '').toString() : '';

      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const rank = findNextSiblingRank(rows, geneKey, siblingContext.parentPrefix, siblingContext.level);
          if (!rank) throw new Error('Plus de rang frère/soeur disponible (a-z)');
          siblingGene = `${siblingContext.parentPrefix}${siblingContext.level}${rank}&`;
          return fetch('/api/row', { method: 'POST' });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec ajout ligne: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Ajout ligne échoué');
          siblingId = data.row && data.row[idKey];
          if (!siblingId) throw new Error('Nouvel ID frère/soeur introuvable');
          return fetch(`/api/row/${encodeURIComponent(siblingId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: geneKey, value: siblingGene })
          });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec update Gene frère/soeur: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Update frère/soeur échoué');
          if (!nomKey) return { ok: true };
          return fetch(`/api/row/${encodeURIComponent(siblingId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: nomKey, value: currentNom })
          })
            .then(res => {
              if (!res.ok) throw new Error('Echec update Nom frère/soeur: ' + res.status);
              return res.json();
            });
        })
        .then(data => {
          if (data && data.ok === false) throw new Error(data.error || 'Update frère/soeur échoué');
          statusEl.textContent = `Frère/soeur ajouté (Gene=${siblingGene}).`;
          trace(`Frere/soeur ajouté: id=${siblingId}, Gene=${siblingGene}`);
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          window.location.href = `QuiDetail.html?id=${encodeURIComponent(siblingId)}`;
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur ajout frere/soeur: ' + err.message);
        })
        .finally(() => {
          addSiblingBtn.disabled = false;
        });
    }

    if (!requestedId) {
      statusEl.textContent = 'Aucun identifiant fourni (paramètre id manquant).';
      trace('Paramètre id manquant');
    } else {
      trace(`Début fetch API /api/row/${requestedId}`);
      fetch(`/api/row/${encodeURIComponent(requestedId)}`, { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error(`Echec de chargement: ${res.status}`);
          trace(`Réponse OK, statut ${res.status}`);
          return res.json();
        })
        .then(data => {
          if (!data.row) throw new Error('Réponse sans donnée');
          headers = data.headers || [];
          currentRow = data.row;
          idKey = headers.find(h => h.toLowerCase() === 'id');
          statusEl.textContent = '';
          render(headers, currentRow);
          trace('Rendu terminé depuis API');
        })
        .catch(err => {
          console.error(err);
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`Erreur: ${err.message}`);
        });
    }

    saveBtn.addEventListener('click', () => {
      saveBtn.disabled = true;
      statusEl.textContent = 'Enregistrement...';
      fetch('/api/save', { method: 'POST' })
        .then(res => {
          if (!res.ok) throw new Error('Echec sauvegarde: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Sauvegarde échouée');
          statusEl.textContent = `Sauvegardé (${data.saved} lignes)`;
          trace('Sauvegarde CSV réussie');
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur sauvegarde: ' + err.message);
        })
        .finally(() => {
          saveBtn.disabled = false;
        });
    });

    deleteBtn.addEventListener('click', deleteRow);
    addChildBtn.addEventListener('click', addChild);
    addSpouseBtn.addEventListener('click', addSpouse);
    addSiblingBtn.addEventListener('click', addSibling);
    goParentBtn.addEventListener('click', goParent);
    goSpouseBtn.addEventListener('click', goSpouse);
    goFirstChildBtn.addEventListener('click', goFirstChild);
    goNextSiblingBtn.addEventListener('click', () => goSibling(1));
    goPrevSiblingBtn.addEventListener('click', () => goSibling(-1));

    function applyDigitConstraints(fieldName, input) {
      if (fieldName.endsWith('_AAAA')) {
        input.maxLength = 4;
        input.placeholder = 'AAAA';
        input.inputMode = 'numeric';
        input.pattern = '\\d{0,4}';
        input.style.width = '60px';
        input.addEventListener('keydown', enforceDigitKey);
        input.addEventListener('paste', enforceDigitPaste);
        input.addEventListener('input', () => {
          input.value = input.value.replace(/\\D+/g, '').slice(0, 4);
        });
      } else if (fieldName.endsWith('_MM') || fieldName.endsWith('_JJ')) {
        input.maxLength = 2;
        input.placeholder = fieldName.endsWith('_MM') ? 'MM' : 'JJ';
        input.inputMode = 'numeric';
        input.pattern = '\\d{0,2}';
        input.style.width = '40px';
        input.addEventListener('keydown', enforceDigitKey);
        input.addEventListener('paste', enforceDigitPaste);
        input.addEventListener('input', () => {
          input.value = input.value.replace(/\\D+/g, '').slice(0, 2);
        });
      } else if (fieldName === 'S') {
        input.maxLength = 1;
        input.placeholder = 'M/F';
        input.pattern = '[MF]';
        input.style.width = '40px';
        input.addEventListener('keydown', enforceSexKey);
        input.addEventListener('paste', enforceSexPaste);
        input.addEventListener('input', () => {
          input.value = normalizeSexValue(input.value);
        });
      }
    }

    function enforceDigitKey(e) {
      const allowed = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (allowed.includes(e.key)) return;
      if (!/^[0-9]$/.test(e.key)) {
        e.preventDefault();
      }
    }

    function enforceDigitPaste(e) {
      e.preventDefault();
      const pasted = (e.clipboardData || window.clipboardData).getData('text') || '';
      const digits = pasted.replace(/\\D+/g, '');
      const max = e.target.maxLength > 0 ? e.target.maxLength : digits.length;
      const insert = digits.slice(0, max);
      const start = e.target.selectionStart ?? e.target.value.length;
      const end = e.target.selectionEnd ?? e.target.value.length;
      const value = e.target.value;
      e.target.value = value.slice(0, start) + insert + value.slice(end);
      const pos = start + insert.length;
      e.target.setSelectionRange(pos, pos);
      e.target.dispatchEvent(new Event('input'));
    }

    function normalizeSexValue(value) {
      const normalized = (value ?? '').toString().toUpperCase().replace(/[^MF]/g, '');
      return normalized.slice(0, 1);
    }

    function enforceSexKey(e) {
      const allowed = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (allowed.includes(e.key)) return;
      if (!/^[mMfF]$/.test(e.key)) {
        e.preventDefault();
      }
    }

    function enforceSexPaste(e) {
      e.preventDefault();
      const pasted = (e.clipboardData || window.clipboardData).getData('text') || '';
      const value = normalizeSexValue(pasted);
      e.target.value = value;
      e.target.dispatchEvent(new Event('input'));
    }

    function normalizeFieldValue(fieldName, value) {
      const str = (value ?? '').toString();
      if (fieldName === 'Nom') return str.toUpperCase();
      if (fieldName === 'Prenom') {
        return str
          .toLowerCase()
          .replace(/(^|[\s'-])(\p{L})/gu, (match, sep, letter) => sep + letter.toUpperCase());
      }
      return str;
    }
  </script>
</body>
</html>


