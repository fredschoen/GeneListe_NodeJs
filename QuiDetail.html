<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GeneListe - Détail</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    table { border-collapse: collapse; margin-top: 5px; }
    th, td { border: 1px solid #ccc; padding: 0.4rem 0.6rem; text-align: left; }
    th { background: #f3f3f3; }
    .danger { background: #ffefef; border: 1px solid #ff6b6b; color: #b00000; }
  </style>
</head>
<body>
  <h1>Détail de l'entrée</h1>
  <div id="status">Chargement...</div>
  <button id="save-btn" disabled>Enregistrer</button>
  <button id="delete-btn" class="danger" disabled>Supprimer</button>
  <button id="add-child-btn" disabled>Ajouter un enfant</button>
  <table id="detail-table" hidden>
    <tbody></tbody>
  </table>
  <button id="trace-toggle-btn" type="button">Afficher la trace</button>
  <pre id="trace" hidden style="background:#f5f5f5;border:1px solid #ccc;padding:0.5rem;white-space:pre-wrap;max-height:200px;overflow:auto;"></pre>

  <script>
    const params = new URLSearchParams(window.location.search);
    const requestedId = params.get('id');
    const statusEl = document.getElementById('status');
    const saveBtn = document.getElementById('save-btn');
    const deleteBtn = document.getElementById('delete-btn');
    const addChildBtn = document.getElementById('add-child-btn');
    const traceToggleBtn = document.getElementById('trace-toggle-btn');
    const traceEl = document.getElementById('trace');
    const table = document.getElementById('detail-table');
    const tbody = table.querySelector('tbody');
    let headers = [];
    let currentRow = {};
    let idKey = null;

    function trace(message) {
      const line = `[${new Date().toISOString()}] ${message}`;
      console.log(line);
      traceEl.textContent = `${line}\n${traceEl.textContent}`;
    }

    function setupTraceToggle() {
      traceToggleBtn.textContent = traceEl.hidden ? 'Afficher la trace' : 'Masquer la trace';
      traceToggleBtn.addEventListener('click', () => {
        traceEl.hidden = !traceEl.hidden;
        traceToggleBtn.textContent = traceEl.hidden ? 'Afficher la trace' : 'Masquer la trace';
      });
    }

    setupTraceToggle();
    trace('QuiDetail: script chargé');
    trace(`URL=${window.location.href}`);

    function render(headers, row) {
      tbody.innerHTML = '';
      saveBtn.disabled = false;
      deleteBtn.disabled = false;
      addChildBtn.disabled = false;
      const visibleHeaders = headers.filter(h => h !== idKey);
      visibleHeaders.forEach((h, idx) => {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        const td = document.createElement('td');
        th.textContent = h;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = row[h] ?? '';
        applyDigitConstraints(h, input);
        input.addEventListener('change', () => {
          const normalizedValue = normalizeFieldValue(h, input.value);
          if (input.value !== normalizedValue) input.value = normalizedValue;
          updateField(row[idKey], h, normalizedValue, td);
        });
        td.appendChild(input);
        tr.appendChild(th);
        tr.appendChild(td);
        tbody.appendChild(tr);
      });
      table.hidden = false;
    }

    function updateField(id, field, value, cell) {
      if (!id) {
        trace('ID manquant, mise à jour annulée');
        return;
      }
      cell.classList.add('saving');
      fetch(`/api/row/${encodeURIComponent(id)}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ field, value })
      })
        .then(res => res.json())
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Mise à jour échouée');
          currentRow[field] = value;
          trace(`Champ ${field} de l'id ${id} mis à jour en mémoire`);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`Erreur mise à jour: ${err.message}`);
        })
        .finally(() => {
          cell.classList.remove('saving');
        });
    }

    function deleteRow() {
      if (!idKey || !currentRow[idKey]) return;
      const c2 = headers[1] ? currentRow[headers[1]] : '';
      const c3 = headers[2] ? currentRow[headers[2]] : '';
      const msg = `Confirmer la suppression de ${c2} ${c3}`.trim();
      if (!confirm(msg)) return;
      deleteBtn.disabled = true;
      statusEl.textContent = 'Suppression...';
      fetch(`/api/row/${encodeURIComponent(currentRow[idKey])}`, { method: 'DELETE' })
        .then(res => {
          if (!res.ok) throw new Error('Echec suppression: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Suppression échouée');
          statusEl.textContent = 'Supprimé. Pensez à enregistrer.';
          trace(`Suppression id=${currentRow[idKey]} réussie`);
          // Optionnel : vider l'affichage
          table.hidden = true;
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          setTimeout(() => window.close(), 200);
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur suppression: ' + err.message);
          deleteBtn.disabled = false;
        });
    }

    function normalizeGeneBase(geneValue) {
      let gene = (geneValue ?? '').toString().trim();
      if (!gene) return '';
      if (gene.endsWith('&0')) {
        gene = gene.slice(0, -2);
      }
      if (!gene.endsWith('&')) {
        gene += '&';
      }
      return gene;
    }

    function extractNextLevel(baseGene) {
      const levels = Array.from(baseGene.matchAll(/&(\d+)[a-z]+/gi))
        .map(m => Number(m[1]))
        .filter(n => Number.isFinite(n));
      if (!levels.length) return 1;
      const lastLevel = levels[levels.length - 1];
      if (!Number.isFinite(lastLevel)) return 1;
      return lastLevel + 1;
    }

    function findNextChildRank(rows, geneKey, baseGene, level) {
      const prefix = `${baseGene}${level}`;
      const used = new Set();
      rows.forEach(row => {
        const g = (row[geneKey] ?? '').toString().trim();
        if (!g.startsWith(prefix)) return;
        const rest = g.slice(prefix.length);
        const m = /^([a-z]+)&/i.exec(rest);
        if (m) used.add(m[1].toLowerCase());
      });
      for (let code = 97; code <= 122; code += 1) {
        const letter = String.fromCharCode(code);
        if (!used.has(letter)) return letter;
      }
      return null;
    }

    function addChild() {
      if (!idKey || !currentRow[idKey]) return;
      const geneKey = headers.find(h => h.toLowerCase() === 'gene');
      const nomKey = headers.find(h => h.toLowerCase() === 'nom');
      if (!geneKey) {
        statusEl.textContent = 'Erreur: colonne Gene absente.';
        trace('Ajout enfant annulé: colonne Gene absente');
        return;
      }
      const parentGene = normalizeGeneBase(currentRow[geneKey]);
      if (!parentGene) {
        statusEl.textContent = 'Erreur: Gene parent vide.';
        trace('Ajout enfant annulé: Gene parent vide');
        return;
      }

      addChildBtn.disabled = true;
      statusEl.textContent = 'Ajout enfant...';

      let childId = null;
      let childGene = null;
      const parentNom = nomKey ? (currentRow[nomKey] ?? '').toString() : '';

      fetch('/api/data', { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error('Echec lecture data: ' + res.status);
          return res.json();
        })
        .then(data => {
          const rows = data.rows || [];
          const level = extractNextLevel(parentGene);
          const rank = findNextChildRank(rows, geneKey, parentGene, level);
          if (!rank) throw new Error('Plus de rang enfant disponible (a-z)');
          childGene = `${parentGene}${level}${rank}&`;
          return fetch('/api/row', { method: 'POST' });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec ajout ligne: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Ajout ligne échoué');
          childId = data.row && data.row[idKey];
          if (!childId) throw new Error('Nouvel ID introuvable');
          return fetch(`/api/row/${encodeURIComponent(childId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: geneKey, value: childGene })
          });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec update Nom enfant: ' + res.status);
          if (!nomKey) return { ok: true, json: () => Promise.resolve({ ok: true }) };
          return fetch(`/api/row/${encodeURIComponent(childId)}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ field: nomKey, value: parentNom })
          });
        })
        .then(res => {
          if (!res.ok) throw new Error('Echec update Nom enfant: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Update enfant échoué');
          statusEl.textContent = `Enfant ajouté (id=${childId}, Gene=${childGene}).`;
          trace(`Enfant ajouté: id=${childId}, Gene=${childGene}`);
          if (window.opener && typeof window.opener.refreshFromDetail === 'function') {
            try { window.opener.refreshFromDetail(); } catch (err) { console.warn(err); }
          }
          window.location.href = `QuiDetail.html?id=${encodeURIComponent(childId)}`;
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur ajout enfant: ' + err.message);
        })
        .finally(() => {
          addChildBtn.disabled = false;
        });
    }

    if (!requestedId) {
      statusEl.textContent = 'Aucun identifiant fourni (paramètre id manquant).';
      trace('Paramètre id manquant');
    } else {
      trace(`Début fetch API /api/row/${requestedId}`);
      fetch(`/api/row/${encodeURIComponent(requestedId)}`, { cache: 'no-store' })
        .then(res => {
          if (!res.ok) throw new Error(`Echec de chargement: ${res.status}`);
          trace(`Réponse OK, statut ${res.status}`);
          return res.json();
        })
        .then(data => {
          if (!data.row) throw new Error('Réponse sans donnée');
          headers = data.headers || [];
          currentRow = data.row;
          idKey = headers.find(h => h.toLowerCase() === 'id');
          statusEl.textContent = '';
          render(headers, currentRow);
          trace('Rendu terminé depuis API');
        })
        .catch(err => {
          console.error(err);
          statusEl.textContent = 'Erreur: ' + err.message;
          trace(`Erreur: ${err.message}`);
        });
    }

    saveBtn.addEventListener('click', () => {
      saveBtn.disabled = true;
      statusEl.textContent = 'Enregistrement...';
      fetch('/api/save', { method: 'POST' })
        .then(res => {
          if (!res.ok) throw new Error('Echec sauvegarde: ' + res.status);
          return res.json();
        })
        .then(data => {
          if (!data.ok) throw new Error(data.error || 'Sauvegarde échouée');
          statusEl.textContent = `Sauvegardé (${data.saved} lignes)`;
          trace('Sauvegarde CSV réussie');
        })
        .catch(err => {
          statusEl.textContent = 'Erreur: ' + err.message;
          trace('Erreur sauvegarde: ' + err.message);
        })
        .finally(() => {
          saveBtn.disabled = false;
        });
    });

    deleteBtn.addEventListener('click', deleteRow);
    addChildBtn.addEventListener('click', addChild);

    function applyDigitConstraints(fieldName, input) {
      if (fieldName.endsWith('_AAAA')) {
        input.maxLength = 4;
        input.placeholder = 'AAAA';
        input.inputMode = 'numeric';
        input.pattern = '\\d{0,4}';
        input.style.width = '60px';
        input.addEventListener('keydown', enforceDigitKey);
        input.addEventListener('paste', enforceDigitPaste);
        input.addEventListener('input', () => {
          input.value = input.value.replace(/\\D+/g, '').slice(0, 4);
        });
      } else if (fieldName.endsWith('_MM') || fieldName.endsWith('_JJ')) {
        input.maxLength = 2;
        input.placeholder = fieldName.endsWith('_MM') ? 'MM' : 'JJ';
        input.inputMode = 'numeric';
        input.pattern = '\\d{0,2}';
        input.style.width = '40px';
        input.addEventListener('keydown', enforceDigitKey);
        input.addEventListener('paste', enforceDigitPaste);
        input.addEventListener('input', () => {
          input.value = input.value.replace(/\\D+/g, '').slice(0, 2);
        });
      } else if (fieldName === 'S') {
        input.maxLength = 1;
        input.placeholder = 'M/F';
        input.pattern = '[MF]';
        input.style.width = '40px';
        input.addEventListener('keydown', enforceSexKey);
        input.addEventListener('paste', enforceSexPaste);
        input.addEventListener('input', () => {
          input.value = normalizeSexValue(input.value);
        });
      }
    }

    function enforceDigitKey(e) {
      const allowed = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (allowed.includes(e.key)) return;
      if (!/^[0-9]$/.test(e.key)) {
        e.preventDefault();
      }
    }

    function enforceDigitPaste(e) {
      e.preventDefault();
      const pasted = (e.clipboardData || window.clipboardData).getData('text') || '';
      const digits = pasted.replace(/\\D+/g, '');
      const max = e.target.maxLength > 0 ? e.target.maxLength : digits.length;
      const insert = digits.slice(0, max);
      const start = e.target.selectionStart ?? e.target.value.length;
      const end = e.target.selectionEnd ?? e.target.value.length;
      const value = e.target.value;
      e.target.value = value.slice(0, start) + insert + value.slice(end);
      const pos = start + insert.length;
      e.target.setSelectionRange(pos, pos);
      e.target.dispatchEvent(new Event('input'));
    }

    function normalizeSexValue(value) {
      const normalized = (value ?? '').toString().toUpperCase().replace(/[^MF]/g, '');
      return normalized.slice(0, 1);
    }

    function enforceSexKey(e) {
      const allowed = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
      if (allowed.includes(e.key)) return;
      if (!/^[mMfF]$/.test(e.key)) {
        e.preventDefault();
      }
    }

    function enforceSexPaste(e) {
      e.preventDefault();
      const pasted = (e.clipboardData || window.clipboardData).getData('text') || '';
      const value = normalizeSexValue(pasted);
      e.target.value = value;
      e.target.dispatchEvent(new Event('input'));
    }

    function normalizeFieldValue(fieldName, value) {
      const str = (value ?? '').toString();
      if (fieldName === 'Nom') return str.toUpperCase();
      if (fieldName === 'Prenom') {
        return str
          .toLowerCase()
          .replace(/(^|[\s'-])(\p{L})/gu, (match, sep, letter) => sep + letter.toUpperCase());
      }
      return str;
    }
  </script>
</body>
</html>


